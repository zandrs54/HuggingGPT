"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
Object.defineProperty(exports, "__esModule", { value: true });
const promises_1 = require("fs/promises");
const crypto_1 = require("crypto");
/**
 * ChatBot class for managing conversations and interactions with models on Hugging Face.
 */
class ChatBot {
    /**
     * Constructs a new instance of the ChatBot class.
     * @param {string} cookie - The user's authentication cookie.
     * @param {string} path - The path to a file containing the authentication cookie.
     * @throws {Error} If both `cookie` and `path` are provided or if neither is provided.
     */
    constructor(cookie, path) {
        this.chatLength = 0;
        this.models = [
            "meta-llama/Llama-2-70b-chat-hf",
            "codellama/CodeLlama-34b-Instruct-hf",
            "tiiuae/falcon-180B-chat",
            "mistralai/Mistral-7B-Instruct-v0.1",
        ];
        this.headers = {
            accept: "*/*",
            "accept-language": "en-US,en;q=0.9",
            "sec-ch-ua": '"Chromium";v="116", "Not)A;Brand";v="24", "Google Chrome";v="116"',
            "sec-ch-ua-mobile": "?0",
            "sec-ch-ua-platform": '"Windows"',
            "sec-fetch-dest": "empty",
            "sec-fetch-mode": "cors",
            "sec-fetch-site": "same-origin",
            "Referrer-Policy": "strict-origin-when-cross-origin",
        };
        this.currentModel = this.models[0];
        if (!cookie && !path)
            throw new Error("cookie or path of cookie required");
        else if (cookie && path)
            throw new Error("both cookie and path given");
        else if (cookie && !path)
            this.cookie = cookie;
        else
            this.readCookiesFromPath(path);
    }
    /**
     * Switches the active model for the chat.
     * @param {'meta-llama/Llama-2-70b-chat-hf' | 'codellama/CodeLlama-34b-Instruct-hf' |'mistralai/Mistral-7B-Instruct-v0.1'|'mistralai/Mistral-7B-Instruct-v0.2' |'NousResearch/Nous-Hermes-2-Mixtral-8x7B-DPO'|'openchat/openchat-3.5-0106'} value - The model to switch to.
     */
    switchModel(value) {
        this.currentConversionID = "";
        this.currentModel = value;
    }
    /**
     * Lists available models that can be used with the chat.
     * @returns {string[]} An array of available model names.
     */
    listAvilableModels() {
        return this.models;
    }
    /**
     * Reads cookies from a file path and sets them for authentication.
     * @param {string} path - The path to the file containing cookies.
     * @throws {Error} If `path` is undefined or if there is an error reading the file.
     */
    readCookiesFromPath(path) {
        var _a, e_1, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            if (!path)
                throw new Error("cookie path undefined");
            const file = yield (0, promises_1.open)(path);
            try {
                for (var _d = true, _e = __asyncValues(file.readLines()), _f; _f = yield _e.next(), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const line = _c;
                    this.cookie += line;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield _b.call(_e);
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * Initializes a new chat conversation.
     * @returns {Promise<string>} The conversation ID of the new chat.
     * @throws {Error} If the creation of a new conversation fails.
     */
    getNewChat() {
        return __awaiter(this, void 0, void 0, function* () {
            const model = {
                model: this.currentModel,
            };
            let response = yield fetch("https://huggingface.co/chat/conversation", {
                headers: Object.assign(Object.assign({}, this.headers), { "content-type": "application/json", cookie: this.cookie, Referer: "https://huggingface.co/chat/" }),
                body: JSON.stringify(model),
                method: "POST",
            }).catch((error) => {
                throw new Error("Failed to create new conversion" + error);
            });
            const { conversationId } = yield response.json().catch((error) => {
                throw new Error("Unknown response " + error);
            });
            this.currentConversionID = conversationId;
            if (response.status != 200)
                throw new Error("Failed to create new conversion" + response);
            yield this.preserveContext(true);
            return conversationId;
        });
    }
    /**
     * Checks if there is an active conversation ID, and if not, creates a new chat.
     */
    checkConversionId() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.currentConversionID) {
                this.currentConversionID = yield this.getNewChat();
            }
        });
    }
    /**
     * Initiates a chat with the provided text.
     * @param {string} text - The user's input text or prompt.
     * @param {string} currentConversionID - The conversation ID for the current chat.
     * @param {number} temperature - Temperature for text generation.
     * @param {number} truncate - Maximum number of tokens in the generated response.
     * @param {number} max_new_tokens - Maximum number of new tokens to generate.
     * @param {number} top_p - Top-p value for text generation.
     * @param {number} repetition_penalty - Repetition penalty for generated text.
     * @param {number} top_k - Top-k value for text generation.
     * @param {boolean} return_full_text - Whether to return the full text of the conversation.
     * @param {boolean} stream - Whether to use streaming for text generation.
     * @param {boolean} use_cache - Whether to use cached results for text generation.
     * @param {boolean} is_retry - Whether the request is a retry.
     * @returns {Promise<ChatResponse>} An object containing conversation details.
     * @throws {Error} If there is an issue with the chat request.
     */
    chat(text, currentConversionID, temperature = 0.1, truncate = 1000, max_new_tokens = 1024, top_p = 0.95, repetition_penalty = 1.2, top_k = 50, return_full_text = false, stream = true, use_cache = false, is_retry = false) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (text == "")
                throw new Error("the prompt can not be empty.");
            if (!currentConversionID)
                yield this.checkConversionId();
            else
                this.currentConversionID = currentConversionID;
            const data = {
                inputs: text,
                parameters: {
                    temperature: temperature,
                    truncate: truncate,
                    max_new_tokens: max_new_tokens,
                    top_p: top_p,
                    repetition_penalty: repetition_penalty,
                    top_k: top_k,
                    return_full_text: return_full_text,
                },
                stream: stream,
                options: {
                    id: (0, crypto_1.randomUUID)(),
                    response_id: (0, crypto_1.randomUUID)(),
                    is_retry: is_retry,
                    use_cache: use_cache,
                    web_search_id: "",
                },
            };
            const response = yield fetch("https://huggingface.co/chat/conversation/" +
                this.currentConversionID +
                "", {
                headers: Object.assign(Object.assign({}, this.headers), { "content-type": "application/json", cookie: this.cookie, Referer: "https://huggingface.co/chat/conversation/" +
                        this.currentConversionID +
                        "" }),
                body: JSON.stringify(data),
                method: "POST",
            });
            function parseResponse(chunck) {
                try {
                    // check if chunk contains multiple jsons
                    const _jsonArr = chunck.split("}");
                    const newJsonArray = [];
                    for (const val of _jsonArr) {
                        if (val.trim())
                            newJsonArray.push(JSON.parse(val + "}"));
                    }
                    return newJsonArray;
                }
                catch (error) {
                    if (chunck)
                        console.error("Error parsing JSON:", chunck);
                    return [{}];
                }
            }
            const decoder = new TextDecoder();
            const self = this;
            let completeResponse = "";
            const transformStream = new TransformStream({
                transform(chunk, controller) {
                    return __awaiter(this, void 0, void 0, function* () {
                        const decodedChunk = decoder.decode(chunk);
                        try {
                            const modifiedDataArr = parseResponse(decodedChunk);
                            for (const modifiedData of modifiedDataArr) {
                                if (modifiedData.text) {
                                    completeResponse = (modifiedData === null || modifiedData === void 0 ? void 0 : modifiedData.text) || "";
                                    controller.terminate();
                                    if (self.chatLength <= 0) {
                                        yield self.summarizeConversation();
                                    }
                                }
                                else {
                                    completeResponse = modifiedData.text;
                                    controller.enqueue((modifiedData === null || modifiedData === void 0 ? void 0 : modifiedData.token) || "");
                                }
                            }
                        }
                        catch (_a) {
                            console.error(decodedChunk);
                            throw new Error("Error during parsing response");
                        }
                    });
                },
            });
            const modifiedStream = (_a = response.body) === null || _a === void 0 ? void 0 : _a.pipeThrough(transformStream);
            function completeResponsePromise() {
                return __awaiter(this, void 0, void 0, function* () {
                    return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                        if (!modifiedStream) {
                            console.error("modifiedStream undefined");
                        }
                        else {
                            let reader = modifiedStream.getReader();
                            while (true) {
                                const { done, value } = yield reader.read();
                                if (done) {
                                    resolve(completeResponse);
                                    break; // The streaming has ended.
                                }
                            }
                        }
                    }));
                });
            }
            this.chatLength += 1;
            return {
                id: this.currentConversionID,
                stream: modifiedStream,
                completeResponsePromise,
            };
        });
    }
    /**
     * Summarizes the conversation based on its conversation ID.
     * @param {string} conversation_id - The conversation ID to summarize.
     * @returns {Promise<any>} A Promise that resolves to the summarized conversation.
     * @throws {Error} If there is an issue summarizing the conversation.
     */
    summarizeConversation(conversation_id) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!conversation_id) {
                conversation_id = this.currentConversionID;
            }
            const response = yield fetch("https://huggingface.co/chat/conversation/" +
                conversation_id +
                "/summarize", {
                headers: Object.assign(Object.assign({}, this.headers), { cookie: this.cookie, Referer: "https://huggingface.co/chat/conversation/" + conversation_id + "" }),
                body: null,
                method: "POST",
            }).catch((error) => {
                throw new Error("Unable to summarize chat " + error);
            });
            const resJson = yield response.json().catch((error) => {
                throw new Error("Unknown response " + error);
            });
            return resJson;
        });
    }
    /**
     * Preserves the context of the current chat conversation.
     * @param {boolean} newChat - Indicates if a new chat is being preserved.
     * @returns {Promise<Response>} A Promise that resolves to the response from preserving chat context.
     * @throws {Error} If there is an issue preserving chat context.
     */
    preserveContext(newChat) {
        return __awaiter(this, void 0, void 0, function* () {
            let response;
            if (newChat) {
                response = yield fetch("https://huggingface.co/chat/conversation/" +
                    this.currentConversionID +
                    "/__data.json?x-sveltekit-invalidated=1_1", {
                    headers: Object.assign(Object.assign({}, this.headers), { cookie: this.cookie, Referer: "https://huggingface.co/chat/" }),
                    body: null,
                    method: "GET",
                });
            }
            else {
                response = yield fetch("https://huggingface.co/chat/conversation/" +
                    this.currentConversionID +
                    "/__data.json?x-sveltekit-invalidated=1_", {
                    headers: Object.assign(Object.assign({}, this.headers), { cookie: this.cookie, Referer: "https://huggingface.co/chat/conversation/" +
                            this.currentConversionID +
                            "" }),
                    body: null,
                    method: "GET",
                });
            }
            if (response.status != 200)
                throw new Error("Unable to preserve chat context " + response);
            return response;
        });
    }
}
exports.default = ChatBot;
